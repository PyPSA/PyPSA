[1mdiff --git a/pypsa/statistics/expressions.py b/pypsa/statistics/expressions.py[m
[1mindex 251c9c9b..42d2c55e 100644[m
[1m--- a/pypsa/statistics/expressions.py[m
[1m+++ b/pypsa/statistics/expressions.py[m
[36m@@ -2198,7 +2198,7 @@[m [mclass StatisticsAccessor(AbstractStatisticsAccessor):[m
     @MethodHandlerWrapper(handler_class=StatisticHandler, inject_attrs={"n": "_n"})[m
     def carbon_emissions([m
         self,[m
[31m-        comps: str | Sequence[str] | None = ["Generator"],[m
[32m+[m[32m        comps: str | Sequence[str] | None = None,[m
         aggregate_time: str | bool = "sum",[m
         aggregate_groups: Callable | str = "sum",[m
         aggregate_across_components: bool = False,[m
[36m@@ -2270,19 +2270,18 @@[m [mclass StatisticsAccessor(AbstractStatisticsAccessor):[m
 [m
         @pass_empty_series_if_keyerror[m
         def func(n: Network, c: str, port: str) -> pd.Series:[m
[31m-            if c != "Generator":[m
[31m-                return pd.Series(dtype=float)[m
[32m+[m[32m            if c == "Generator":[m
[32m+[m[32m                efficiency = n.get_switchable_as_dense(c, "efficiency")[m
[32m+[m[32m                if not at_port:[m
[32m+[m[32m                    efficiency = abs(efficiency)[m
[32m+[m[32m                weights = get_weightings(n, c)[m
[32m+[m[32m                p = ([m
[32m+[m[32m                    get_operation(n, c).abs()[m
[32m+[m[32m                    / efficiency[m
[32m+[m[32m                    * n.static(c).carrier.map(n.carriers.co2_emissions).fillna(0)[m
[32m+[m[32m                )[m
[32m+[m[32m                return self._aggregate_timeseries(p, weights, agg=aggregate_time)[m
 [m
[31m-            efficiency = n.get_switchable_as_dense(c, "efficiency")[m
[31m-            if not at_port:[m
[31m-                efficiency = abs(efficiency)[m
[31m-            weights = get_weightings(n, c)[m
[31m-            p = ([m
[31m-                get_operation(n, c).abs()[m
[31m-                / efficiency[m
[31m-                * n.static(c).carrier.map(n.carriers.co2_emissions).fillna(0)[m
[31m-            )[m
[31m-            return self._aggregate_timeseries(p, weights, agg=aggregate_time)[m
 [m
         df = self._aggregate_components([m
             func,[m
